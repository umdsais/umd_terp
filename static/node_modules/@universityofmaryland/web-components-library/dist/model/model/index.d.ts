interface AttributeConfig {
    name: string;
    handler: (element: ElementRef, oldValue: string, newValue: string) => void;
}
interface ElementRef {
    element: HTMLElement;
    styles: string;
    events?: Record<string, Function>;
}
interface SlotConfig {
    required?: boolean;
    deprecated?: string;
    allowedElements?: string[];
}
interface ComponentLifecycle {
    beforeConnect?: (ref: ElementRef, shadow: ShadowRoot) => void;
    afterConnect?: (ref: ElementRef, shadow: ShadowRoot) => void;
    onReady?: (ref: ElementRef, shadow: ShadowRoot) => void;
}
interface ComponentConfig extends ComponentLifecycle {
    tagName: string;
    attributes?: AttributeConfig[];
    slots?: Record<string, SlotConfig>;
    createComponent: (host: HTMLElement) => ElementRef;
}
declare const ComponentConfig: (config: ComponentConfig) => <T extends typeof BaseComponent>(constructor: T) => T;
declare class BaseComponent extends HTMLElement {
    static componentConfig: ComponentConfig;
    protected shadow: ShadowRoot;
    protected elementRef: ElementRef | null;
    protected config: ComponentConfig;
    constructor();
    static get observedAttributes(): string[];
    connectedCallback(): void;
    disconnectedCallback(): void;
    attributeChangedCallback(name: string, oldValue: string, newValue: string): void;
    protected initializeComponent(): void;
    protected setupShadowDom(component: ElementRef): void;
    protected validateConfig(): void;
    protected afterInit(): Promise<void>;
    protected handleAttributeChange(name: string, oldValue: string, newValue: string): void;
    protected cleanup(): void;
    protected handleError(message: string, error: unknown): void;
    private validateSlots;
    private executeLifecycleCallbacks;
    private executeCallback;
    getRef(): ElementRef | null;
}
declare const createCustomElement: (config: ComponentConfig) => typeof BaseComponent;
export { createCustomElement, type ElementRef, type ComponentConfig, type AttributeConfig, };
//# sourceMappingURL=index.d.ts.map